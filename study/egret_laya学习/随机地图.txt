/*** 用于地图创建的点* @author nodep* @version 1.0*/class Point2D extends egret.Point{private static _tid:number = 0;public tris:Array<Tri2D> = [];public id:number;public constructor(tx:number=0,ty:number=0){super(tx,ty);this.id = ++Point2D._tid;}}

/*** 未处理的数据多边形* @author nodep* @version 1.0*/class Pol2D { public centerPoint: Point2D;public vertex: Array<Point2D>;public isos: boolean = false; public constructor(points: Array<Point2D>) {this.vertex = points;} /*** 向重心点移动*/public moveToFocus(p: egret.Point): void {this.centerPoint.x = p.x;this.centerPoint.y = p.y;} /*** 根据容器外框大小进行自裁切* @param w* @param h */public cutself(w: number, h: number): void {var key: any;var point: Point2D;var delList: Array<Point2D> = [];for (key in this.vertex) {point = this.vertex[key];if (this.isOutside(w, h, point))//如果自己在外面{        //如果两侧也在外面，删除自己if (this.isOutside(w, h, this.getPrePoint(point)) && this.isOutside(w, h, this.getNextPoint(point)))delList.push(point);}}while (delList.length > 0) {point = delList.pop();this.vertex.splice(this.vertex.indexOf(point), 1);}var outsideCount: number = 0;for (key in this.vertex) {point = this.vertex[key];if (this.isOutside(w, h, point)) {delList.push(point);outsideCount++;}}if (outsideCount == 0)return;this.isos = outsideCount > 0;if (outsideCount > 2)LogTrace.log("数据异常：存在超过2个点在裁切以后外框以外的多边形");var p1: Point2D;var p2: Point2D;var pIndex: number;var nIndex: number;if (outsideCount == 1) {p1 = this.getIntersect(w, h, delList[0], this.getPrePoint(delList[0]));pIndex = this.vertex.indexOf(this.getPrePoint(delList[0]));this.vertex.splice(pIndex + 1, 0, p1);p2 = this.getIntersect(w, h, delList[0], this.getNextPoint(delList[0]));nIndex = this.vertex.indexOf(this.getNextPoint(delList[0]));this.vertex.splice(nIndex - 1, 0, p2);while (delList.length > 0) {point = delList.pop();this.vertex.splice(this.vertex.indexOf(point), 1);}}else if (outsideCount == 2) {if (!this.isOutside(w, h, this.getPrePoint(delList[0])))//如果他的上一个在框内{if (!this.isOutside(w, h, this.getNextPoint(delList[0])))LogTrace.log("数据异常：存在超过2个点在裁切以后外框以外的多边形");p1 = this.getIntersect(w, h, delList[0], this.getPrePoint(delList[0]));pIndex = this.vertex.indexOf(delList[0]);this.vertex[pIndex] = p1;p2 = this.getIntersect(w, h, delList[1], this.getNextPoint(delList[1]));nIndex = this.vertex.indexOf(delList[1]);this.vertex[nIndex] = p2;}else {if (!this.isOutside(w, h, this.getPrePoint(delList[0])))LogTrace.log("数据异常：存在超过2个点在裁切以后外框以外的多边形");p1 = this.getIntersect(w, h, delList[0], this.getNextPoint(delList[0]));pIndex = this.vertex.indexOf(delList[0]);p2 = this.getIntersect(w, h, delList[1], this.getPrePoint(delList[1]));nIndex = this.vertex.indexOf(delList[1]);this.vertex[pIndex] = p1;this.vertex[nIndex] = p2;}//------------------检查是否同边-------------------if (p1.x == p2.x || p1.y == p2.y)//同边return;//这里是不同边,则取他们中间的点var px: number = 0;var py: number = 0;if (p1.x == 0 || p1.x == w)px = p1.x;else if (p2.x == 0 || p2.x == w)px = p2.x;elseLogTrace.log("数据异常：裁切以后边不在边框上"); if (p1.y == 0 || p1.y == h)py = p1.y;else if (p2.y == 0 || p2.y == h)py = p2.y;elseLogTrace.log("数据异常：裁切以后边不在边框上"); if (this.getPrePoint(p1) == p2)this.vertex.splice(this.vertex.indexOf(p2) + 1, 0, new Point2D(px, py));else if (this.getPrePoint(p2) == p1)this.vertex.splice(this.vertex.indexOf(p1) + 1, 0, new Point2D(px, py));elseLogTrace.log("数据异常：插入点有问题");}//2.如果有两个点，则分别向他们的真实点移动。//3.经过上面的处理之后，都会有2个点与边框贴近，我们称为虚拟点。//4.如果虚拟点在同一个边上，不做处理。如果他们不在同一条边上，则计算他们所在边的焦点，以此点为终点，新生成一个虚拟点。插入在他们之间。//5.经过上面的处理之后。得到的就是一个大小可控的范围。再做重心移动操作就不会出现异常出界的问题。//注意：上面所有移动的点都是虚拟替换点，需要删除原有的点。经过这个处理之后，所有的中心点都不会偏移出界。那么三角形的顶点自然也就不会出界。生成的多边形会更平滑} /*** 是否在边界外* @param w* @param h* @param target* @return*/private isOutside(w: number, h: number, target: Point2D): boolean {return target.x < 0 || target.y < 0 || target.x > w || target.y > h;} /*** 根据ID获取一个Point* @param pid* @return*/public getPointByID(pid: number): Point2D {var target: Point2D;var key: any;var pp: Point2D;for (key in this.vertex) {pp = this.vertex[key];if (pp.id == pid) {target = pp;break;}}return target;} /*** 获取他的上一个* @param target* @return*/public getPrePoint(target: Point2D): Point2D {var returnPoint: Point2D;var index: number = this.vertex.indexOf(target);if (index < 0)return null;if (index == 0)returnPoint = this.vertex[this.vertex.length - 1];elsereturnPoint = this.vertex[index - 1];if (returnPoint == target)LogTrace.log("数据异常：这个四边形只有两个点");return returnPoint;} /*** 获取他的下一个点* @param target* @return*/public getNextPoint(target: Point2D): Point2D {var returnPoint: Point2D;var index: number = this.vertex.indexOf(target);if (index < 0)return null;if (index == this.vertex.length - 1)returnPoint = this.vertex[0];elsereturnPoint = this.vertex[index + 1];if (returnPoint == target)LogTrace.log("数据异常：这个四边形只有两个点");return returnPoint;} /*** 获取一个和外边框相交的点* @param w* @param h* @param fromP 在框外的点* @param toP 在框内的点* @return*/private getIntersect(w: number, h: number, fromP: Point2D, toP: Point2D): Point2D {var dis1: numbervar dis2: number;if ((fromP.x < 0 || fromP.x > w) && (fromP.y < 0 || fromP.y > h))//如果两者同时满足，则看高宽比{var xbz: number;var ybz: number;//检查是x的比值比较大，还是Y的比值比较大if (fromP.y < 0)//上半屏幕{ybz = (toP.y - fromP.y) / toP.y;if (fromP.x < 0)xbz = (toP.x - fromP.x) / toP.x;elsexbz = (fromP.x - toP.x) / (w - toP.x);}else {ybz = (fromP.y - toP.y) / (h - toP.y);if (fromP.x < 0)xbz = (toP.x - fromP.x) / toP.x;elsexbz = (fromP.x - toP.x) / (w - toP.x);}if (xbz > ybz)//如果x偏差大{if (fromP.x < 0) {dis1 = toP.x - fromP.x;dis2 = toP.x;}else {dis1 = fromP.x - toP.x;dis2 = w - toP.x;}}else//如果y的偏差大{if (fromP.y < 0) {dis1 = toP.y - fromP.y;dis2 = toP.y;}else {dis1 = fromP.y - toP.y;dis2 = h - toP.y;}}}else if (fromP.x < 0 || fromP.x > w)//如果x越界{if (fromP.x < 0) {dis1 = toP.x - fromP.x;dis2 = toP.x;}else {dis1 = fromP.x - toP.x;dis2 = w - toP.x;}}else//如果Y越界{if (fromP.y < 0) {dis1 = toP.y - fromP.y;dis2 = toP.y;}else {dis1 = fromP.y - toP.y;dis2 = h - toP.y;}}var p: egret.Point = egret.Point.interpolate(fromP, toP, dis2 / dis1);if (Math.abs(p.x) < 2)p.x = 0;else if (Math.abs(w - p.x) < 2)p.x = w;if (Math.abs(p.y) < 2)p.y = 0;else if (Math.abs(p.y - h) < 2)p.y = h;return new Point2D(p.x, p.y);}}


/*** 业务用三角形* @author nodep* @version 1.0*/class Tri2D { //是否已初始化三角函数public inited: boolean = false;//顶点public vertex: Array<Point2D>;//外接圆心public center: Point2D;//外接圆半径public circumR: number = 0;//三角形的三条边public edges: Array<Edge2D> = new Array<Edge2D>(3);//是否属于辅助三角形public isAssist: boolean = false;/**重心*/public focusPoint: egret.Point;/**面积*/public area: number; public constructor(points: Array<Point2D>, autoBuild: boolean = true) {this.vertex = points;this.vertex[0].tris.push(this);this.vertex[1].tris.push(this);this.vertex[2].tris.push(this);this.inited = autoBuild;this.edges[0] = new Edge2D(points[0], points[1]);this.edges[1] = new Edge2D(points[1], points[2]);this.edges[2] = new Edge2D(points[2], points[0]);if (this.inited)this.flush();} /*** 刷新三角形的重要属性*/public flush(): void {this.inited = true;this.center = TriangleUtil.getCircumcirclePoint(this);this.circumR = TriangleUtil.getCircumcircleR(this);} /**三角形被销毁*/public del(): void {this.vertex[0].tris.splice(this.vertex[0].tris.indexOf(this), 1);this.vertex[1].tris.splice(this.vertex[1].tris.indexOf(this), 1);this.vertex[2].tris.splice(this.vertex[2].tris.indexOf(this), 1);}}

/**
* 维若图用边数据结构
* @author nodep
* @version 1.0
*/
class Edge2D {
public id: string;
public startPoint: Point2D;
public endPoint: Point2D;
public constructor(p1: Point2D, p2: Point2D) {
if (p1.id > p2.id) {
this.startPoint = p2;
this.endPoint = p1;
}
else {
this.startPoint = p1;
this.endPoint = p2;
}
this.id = this.startPoint.id + "_" + this.endPoint.id;
}
}

/*** 基于三角形和多边形的随机地图生成类* @author nodep* @version 1.0*/class LloydUtil { private _assistPoints: Array<Point2D>;private _points: Array<Point2D>;private _tris: Array<Tri2D>;private _polgons: Array<Pol2D>;private _maxW: number;private _maxH: number; /*** 构造一个算法结构* @param points* @param maxW* @param maxH*/public constructor(points: Array<number>, maxW: number, maxH: number) {this._points = new Array<Point2D>();var index: number = 0;var p2d: Point2D;while (index < points.length) {p2d = new Point2D(points[index], points[index + 1]);this._points.push(p2d);index += 2;}this._maxW = maxW;this._maxH = maxH;} /**获取多边形*/public getPolgons(): Array<Pol2D> {return this._polgons;} /*** 构造三角形*/public delaunay(): void {this._tris = new Array<Tri2D>();//辅助三角形this._assistPoints = [new Point2D(this._maxW / 2, -10000), new Point2D(this._maxW + 10000, this._maxH), new Point2D(-10000, this._maxH)];this.addTri([this._assistPoints[0], this._assistPoints[1], this._assistPoints[2]]);var index: number = 0;var p2d: Point2D;//三角形插入while (index < this._points.length) {p2d = this._points[index];this.insertPoint(p2d);index++;}} /**像图形中插入一个点*/private insertPoint(p: Point2D): void {//检查外接圆包含此点的三角形var tris: Array<Tri2D> = this.findInsideTri(p);//排除公共边之后剩余的边var edges: Array<Edge2D> = this.delEdgeInCommon(tris);//删除三角形while (tris.length > 0)this.delTri(tris.pop());//用插入的点与剩下的边分别形成新的三角形while (edges.length > 0) {var edge: Edge2D = edges.pop();var tri: Tri2D = this.addTri([p, edge.startPoint, edge.endPoint]);}} /**查询所在三角形,返回所有外接圆范围内的三角形,这个步骤很耗时,可以从设计上进行优化*/private findInsideTri(p: Point2D): Array<Tri2D> {var key: any;var tri: Tri2D;var list: Array<Tri2D> = [];for (key in this._tris) {tri = this._tris[key];if (TriangleUtil.isInCircumcircle(p, tri))list.push(tri);}return list;} /*** 删除这些三角形的公共边,并返回他们剩下的边* @param tris*/private delEdgeInCommon(tris: Array<Tri2D>): Array<Edge2D> {var key: any;var lastEdges: Array<string> = [];var sameEdges: Array<string> = [];var returnEdgs: Array<Edge2D> = [];var tri: Tri2D;for (key in tris) {tri = tris[key];var edge: Edge2D;for (key in tri.edges) {edge = tri.edges[key];if (lastEdges.indexOf(edge.id) < 0) {lastEdges.push(edge.id);returnEdgs.push(edge);}elsesameEdges.push(edge.id);}}var i: number = returnEdgs.length - 1;for (i; i >= 0; i--) {if (sameEdges.indexOf((returnEdgs[i] as Edge2D).id) >= 0)returnEdgs.splice(i, 1);}return returnEdgs;} /*** 从列表中删除一个三角形* @param tri*/private delTri(tri: Tri2D): void {this._tris.splice(this._tris.indexOf(tri), 1);tri.del();} /*** 项列表中添加一个三角形* @param points* @return*/private addTri(points: Array<Point2D>): Tri2D {var v: Array<Point2D> = new Array<Point2D>(3);v[0] = points[0];v[1] = points[1];v[2] = points[2];var tri: Tri2D = new Tri2D(v);this._tris.push(tri);return tri;} /*** 进行优化* 1.循环所有的四边形，移动他的重心* 2.刷新所有三角形数据* 3.重新生成四边形数据**/public optimization(): void {var key: any;//像重心点移动,还有一个办法是每个三角形角度最小的那个点，向对边垂线靠近var pol: Pol2D;for (key in this._polgons)this._polgons[key].moveToFocus(LloydUtil.getFoucsPoint(this._polgons[key]));this._tris = [];var p2d: Point2D;for (key in this._points) {p2d = this._points[key];p2d.tris = [];}this.delaunay();//分割三角形this.voronoi();//创建四边形} /*n边多边形可以分成n-2个三角形，将这些三角形看做质点（质点的位置是三角形的重心x1,x2,..，质量是面积s1,s2,..），那么多边形就由这些质点组成，质点坐标以其质量为权的加权算术平均数即是多边形重心坐标x。x=(x1*s1+x2*s2+...)/(s1+s2+...)s=s1+s2+...*//**获取多边形的重心点*///该算法分凸多边形和任意多边形public static getFoucsPoint(pol: Pol2D): egret.Point {var tS: number = 0;var S: number = 0;var sx: number = 0;var sy: number = 0.; //S面积,xy横纵坐标和  for (var i: number = 0; i < pol.vertex.length; i++) {var t0: number = i;var t1: number = i + 1;if (t1 == pol.vertex.length)t1 = 0;tS = this.cross(pol.vertex[t0], pol.vertex[t1]) / 2.;S += tS;sx += tS * (pol.vertex[t0].x + pol.vertex[t1].x) / 3;sy += tS * (pol.vertex[t0].y + pol.vertex[t1].y) / 3;}return new egret.Point(sx / S, sy / S);} private static cross(p1: egret.Point, p2: egret.Point): number {return p1.x * p2.y - p1.y * p2.x;} /**通过voronoi算法算出多边形*/public voronoi(): void {this._polgons = new Array<Pol2D>();var key: any;var p2d: Point2D;for (key in this._points) {p2d = this._points[key];var pol: Pol2D = this.createPolygon(p2d);pol.cutself(this._maxW, this._maxH);if (pol.vertex.length >= 3)this._polgons.push(pol);elseLogTrace.log("数据异常：四边形的边的数量异常");}} /*** 寻找一个相邻的三角形* @param fromTri 查询的对象* @param exclude 排除的三角对象* @param all 查询的范围* @return*/private findAdjacent(fromTri: Tri2D, exclude: Array<Tri2D>, all: Array<Tri2D>): Tri2D {var target: Tri2D = null;var key: any;var tri: Tri2D;for (key in all) {tri = all[key];if (exclude.indexOf(tri) >= 0)continue;if (TriangleUtil.isAdjacent(fromTri, tri)) {target = tri;break;}}return target;} /*** 因为三角形的顶点，就是多边形的中心点* 通过这个顶点可以找到拥有这个顶点的三角形* 按照相邻连接的方法将这些三角形的外接圆圆心点连接起来，就是一个多边形*/private createPolygon(p2d: Point2D): Pol2D {var tris: Array<Tri2D> = p2d.tris;var startTri: Tri2D = tris[0];var pcList: Array<Tri2D> = [startTri];//有一种特殊情况，那就是如果三角形的循环无法有效的回归，则说明这个多边形需要进行补充。//在无法衔接的这两个三角形里，非共同边但拥有p2d端点的那个线段，就是需要进行补充的线段。而当前的这个三角形的外接圆心到这条边中线的延长线，就是边界焦点。//将焦点连接中心点，形成一个新的三角形。//之后在反向查询一次，如果无法连同，则再次执行上两步//两边都执行一次之后，这个三角形百分百的与外边框相连接。这个时候判断新生成大的两个三角形的焦点是否在同一条边框上，如果在，用他们两个和中心点构成新的三角形。//如果不在，以他们两个点外加边框边缘，形成2个是三角形加入数组。再执行通路检测var xlTri: Tri2D = this.findAdjacent(startTri, pcList, tris);var lastTri: Tri2D = xlTri;var tCount: number = 2;while (xlTri != null) {pcList.push(xlTri);lastTri = xlTri;xlTri = this.findAdjacent(xlTri, pcList, tris);tCount++;}if (!(TriangleUtil.isAdjacent(lastTri, startTri) && tCount >= 3)) {LogTrace.log("存在无法构造的多边形");}var points: Array<Point2D> = new Array<Point2D>();for (var i: number = 0; i < pcList.length; i++)points.push((pcList[i] as Tri2D).center);var polyGon2D: Pol2D = new Pol2D(points);polyGon2D.centerPoint = p2d;return polyGon2D;} /*** 螺旋循环获取一个新的坐标* @param startX* @param startY* @param movePoint* @return*/private screwFind(startX: number, startY: number, movePoint: egret.Point): egret.Point {var point: egret.Point = new egret.Point();if (movePoint.x == movePoint.y && movePoint.x >= 0 && movePoint.y >= 0)//判断是否已循环完一圈movePoint.y = movePoint.y + 1;else if (Math.abs(movePoint.x) == Math.abs(movePoint.y))//是否需要转角{if (movePoint.x < 0 && movePoint.y > 0)movePoint.y = movePoint.y - 1;else if (movePoint.x < 0 && movePoint.y < 0)movePoint.x = movePoint.x + 1;elsemovePoint.y = movePoint.y + 1;}else//只是普通的位移,需要判断x,y谁的绝对值更大。然后再区分方向{if (Math.abs(movePoint.y) > Math.abs(movePoint.x))//如果y的绝对值比x大，则是移动ｘ{if (movePoint.y > 0)movePoint.x = movePoint.x - 1;elsemovePoint.x = movePoint.x + 1;}else//否则移动y{if (movePoint.x > 0)movePoint.y = movePoint.y + 1;elsemovePoint.y = movePoint.y - 1;}}point.x = movePoint.x + startX;point.y = movePoint.y + startY;return point;} /**查询拥有的三角形*/private findOwnTris(p: Point2D): Array<Tri2D> {var list: Array<Tri2D> = [];var tri: Tri2D;var key: any;for (key in this._tris) {tri = this._tris[key];if (tri.vertex.indexOf(p) >= 0)list.push(tri);}return list;} /**获取测试形状 */public getTestShape(): egret.Shape {var shape: egret.Shape = new egret.Shape();shape.graphics.li ne Style(1, 0x0000FF, 2);var pol: Pol2D;var key: any;for (key in this._polgons) {pol = this._polgons[key];shape.graphics.beginFill(0xff0000, 0.5);shape.graphics.moveTo(pol.vertex[0].x, pol.vertex[0].y);for (var i: number = 1; i < pol.vertex.length; i++)shape.graphics.li ne To(pol.vertex[i].x, pol.vertex[i].y);shape.graphics.li ne To(pol.vertex[0].x, pol.vertex[0].y);shape.graphics.endFill();}return shape;}}

/** * 三角函数 * @author nodep * @version 1.0 */class TriangleUtil {     /**    * 求外接圆半径    * @param tri    * @return    */    public static getCircumcircleR(tri: Tri2D): number {        var x1: number = tri.vertex[0].x;        var x2: number = tri.vertex[1].x;        var x3: number = tri.vertex[2].x;        var y1: number = tri.vertex[0].y;        var y2: number = tri.vertex[1].y;        var y3: number = tri.vertex[2].y;        var a: number = Math.sqrt( (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) );        var b: number = Math.sqrt( (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3) );        var c: number = Math.sqrt( (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3) );        var p: number = (a + b + c) / 2;        var S: number = Math.sqrt( p * (p - a) * (p - b) * (p - c) );        var radius: number = a * b * c / (4 * S);        return radius;    }      /**     * 求外接圆圆心坐标     * @param tri     * @return     */    public static getCircumcirclePoint(tri: Tri2D): Point2D {        var p: Point2D = new Point2D();        var x1: number = tri.vertex[0].x;        var x2: number = tri.vertex[1].x;        var x3: number = tri.vertex[2].x;        var y1: number = tri.vertex[0].y;        var y2: number = tri.vertex[1].y;        var y3: number = tri.vertex[2].y;        var t1: number = x1 * x1 + y1 * y1;        var t2: number = x2 * x2 + y2 * y2;        var t3: number = x3 * x3 + y3 * y3;        var temp: number = x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2;        p.x = (t2 * y3 + t1 * y2 + t3 * y1 - t2 * y1 - t3 * y2 - t1 * y3) / temp / 2;        p.y = (t3 * x2 + t2 * x1 + t1 * x3 - t1 * x2 - t2 * x3 - t3 * x1) / temp / 2;        return p;    }     /**     * 检查一个点是否在一个三角形的外接圆内。     * @param point     * @param tri     * @return     */    public static isInCircumcircle(point: egret.Point, tri: Tri2D): boolean {        var xd: number = (point.x - tri.center.x);        var yd: number = (point.y - tri.center.y);        return Math.sqrt(xd * xd + yd * yd) <= tri.circumR;    }     /**    * 检查两个三角形是否相邻    * 这个函数所适用的三角形必须是通过特殊流程构造的    * @param triA    * @param triB    */    public static isAdjacent(triA: Tri2D, triB: Tri2D): boolean {        var e1: Edge2D;        var key: any;        for (key in triA.edges) {            e1 = triA.edges[key];            var e2: Edge2D;            for (key in triB.edges) {                e2 = triB.edges[key];                if (e1.id == e2.id)                    return true;            }        }        return false;    }     /**求距离 */    public static distance(x_x: number, y_y: number): number {        return Math.abs(Math.sqrt(x_x * x_x + y_y * y_y));    }}

/** * 关于随机点的应用函数 * @author nodep * @version 1.0 */class RandomPointUtil {     /**     * 根据框的宽高和边框的宽度，获取随机点     */    public static getRandomPoints(sizeW: number, sizeH: number, border: number, num: number): Array<number> {        var pointsStr: Array<string> = new Array<string>();        var points: Array<number> = new Array<number>();        var rx: number;        var ry: number;        var str:string;        while (num > 0) {            rx = Math.floor(Math.random() * (sizeW - border * 2) + border);            ry = Math.floor(Math.random() * (sizeW - border * 2) + border);            str = rx + "_" + ry;            if (pointsStr.indexOf(str) >= 0) {                continue;            }            else {                pointsStr.push(str);                num--;                points.push(rx);                points.push(ry);            }        }        pointsStr = null;        return points;    }}

ar points:Array<number> = RandomPointUtil.getRandomPoints(this._sizeW,this._sizeH,10,1000);//随机点集
                var lloy:LloydUtil = new LloydUtil(points,this._sizeW,this._sizeH);//创建一个工具
                lloy.delaunay();//剖分三角形
                lloy.voronoi();//构造维若图
                lloy.optimization();//优化重心点
                lloy.optimization();
                lloy.optimization();
                lloy.optimization();
                lloy.optimization();